<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clean code | Joel Hooks]]></title>
  <link href="http://joelhooks.com/blog/categories/clean-code/atom.xml" rel="self"/>
  <link href="http://joelhooks.com/"/>
  <updated>2016-07-04T15:44:39-07:00</updated>
  <id>http://joelhooks.com/</id>
  <author>
    <name><![CDATA[Joel Hooks]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Custom Jasmine Matchers to Make Unit Tests More Readable]]></title>
    <link href="http://joelhooks.com/blog/2012/11/17/using-custom-jasmine-matchers-to-make-unit-tests-more-readable/"/>
    <updated>2012-11-17T10:55:00-08:00</updated>
    <id>http://joelhooks.com/blog/2012/11/17/using-custom-jasmine-matchers-to-make-unit-tests-more-readable</id>
    <content type="html"><![CDATA[<p><img src="/images/clean_and_dry.jpg" alt="Clean and Dry" /></p>

<p><a href="http://www.flickr.com/photos/29601732@N06/3969905051/">Image from purplemattfish</a></p>

<p>I&rsquo;m a stickler for the &ldquo;single assertion per test&rdquo; guideline. One of the pillars of good unit tests is readability. Multiple asserts undermine this principle and make tests that are more difficult to read, understand, and maintain. A clean solution to this problem is to use custom Jasmine matchers in place of multiple assertions.</p>

<h2>Keep it DRY, Even (Especially?) in Tests</h2>

<p>Consider the following:</p>

<p><div><script src='https://gist.github.com/4097691.js?file=BloatedDateTest.js'></script>
<noscript><pre><code>it(&quot;convertToDate should turn a splitDate into a Date object&quot;, function() {
    var splitDate = {year: 2012, month: 11, day: 17},
        date = dateUtil.splitDateToDate(splitDate);
    
    expect(date instanceof Date).toBe(true);
    expect(date.getFullYear()).toBe(splitDate.year);
    expect(date.getMonth()).toBe(splitDate.month - 1);
    expect(date.getDate()).toBe(splitDate.day);
});
</code></pre></noscript></div>
</p>

<p>In our app, we recieve a &ldquo;split date&rdquo; object from our service. It returns a value in the <code>{year: 2012, month: 11, day: 17}</code> format. We have some functionality that will convert the format back and for to a JavaScript <code>Date</code>.</p>

<p>This seems straight forward enough, but as it turns out we need to go the other direction as well:</p>

<p><div><script src='https://gist.github.com/4097691.js?file=AnotherBloatedDateTest.js'></script>
<noscript><pre><code>it(&quot;convertToSplitDate should turen a Date into a split date&quot;, function() {
    var date = new Date(2012, 10, 17),
        splitDate = dateUtil.convertDateToSplitDate(date);

    expect(splitDate).toBeDefined();
    expect(splitDate.year).toBe(date.year);
    expect(splitDate.month - 1).toBe(date.month);
    expect(splitDate.day).toBe(date.day);
});</code></pre></noscript></div>
</p>

<p>This is bothersome. We have two stacks of <code>expect</code> calls that are very similar, but different enough to require a bit more than a helper method. We definitely want to verify all of the properties of the results, but do we really need to do this individually? The short answer is &lsquo;no.&rsquo;</p>

<h2>Enter the Custom Matcher</h2>

<p><div><script src='https://gist.github.com/4097691.js?file=CustomMatchers.js'></script>
<noscript><pre><code>//Jasmine will call this before EVERY spec.
beforeEach(function () {
    function isValidSplitDate(splitDate) {
        return splitDate &amp;&amp; !isNaN(splitDate.year) &amp;&amp; !isNaN(splitDate.month) &amp;&amp; !isNaN(splitDate.day);
    }

    function convertSplitDateToDate(splitDate) {
        if (isValidSplitDate(splitDate)) {
            splitDate = new Date(splitDate.year, splitDate.month - 1, splitDate.day);
        }
        return splitDate;
    }
   
    //addMatchers() is a method that Jasmine will see and understand to 
    //make the custom matchers within easy to understand.
    this.addMatchers({
        toEqualDate: function (expectedDate) {
            var areDates;

            expectedDate = convertSplitDateToDate(expectedDate);
            this.actual = convertSplitDateToDate(this.actual);

            areDates = this.actual instanceof Date &amp;&amp; expectedDate instanceof Date;

            //Jasmine will look for this function and utilize it for custom error messages
            this.message = function () {
                if (areDates) {
                    return &quot;Expected date of &quot; + this.actual + &quot; to be &quot; + expectedDate;
                }
                return &quot;Expected &quot; + this.actual + &quot; and &quot; + expectedDate + &quot; to be valid Date/SplitDate objects. They were not.&quot;;
            };

            if (areDates) {
                //Ultimately Jasmine expects a matcher to return true or false
                return (this.actual.getTime() === expectedDate.getTime());
            }

            return false;
        }
    });
});</code></pre></noscript></div>
</p>

<p>A custom matcher is nestled in a <code>beforeEach</code> function. This will cause Jasmine to load the matcher prior to EVERY <code>describe</code> and <code>it</code> in your test suite.</p>

<p>Within the <code>beforeEach</code> is <code>this.addMatcher</code> that takes an <code>object</code> whose properties are your actual custom matchers. In our example the &lsquo;toEqualDate&rsquo; matcher is the only property, but you can add as many as you might need for your application.</p>

<p>In the scope of the <code>toEqualDate</code> function, we pass in the <code>expectedDate</code> parameter. This is the argument passed into <code>toEqualDate(myExpectedDate)</code>. We also have access to <code>this.actual</code> that is the argument passed into <code>expect(myActualDate)</code> within your test.</p>

<p>The next important bit is the <code>this.message</code> function that Jasmine will use to display any custom error messages. In this case we are returning two messages as appropriate. The first will return an invalid match, and the second will return a message if either object is not a valid date (if they are undefined, null, or incorrectly formatted).</p>

<p>Finally the <code>toEqualDate</code> function will return true or false based on the values we are comparing. If they are indeed valid <code>Date</code> objects, it will compare them. If they are not, we return false.</p>

<p>At the top of the <code>beforeEach</code> we also have two utility methods to clean up our custom matcher.</p>

<h2>Keeping it Clean and DRY</h2>

<p><div><script src='https://gist.github.com/4097691.js?file=CleanTests.js'></script>
<noscript><pre><code>it(&quot;convertToDate should turn a splitDate into a Date object&quot;, function() {
    var splitDate = {year: 2012, month: 11, day: 17},
        date = dateUtil.splitDateToDate(splitDate);
    
    expect(date).toEqualDate(splitDate);
});

it(&quot;convertToSplitDate should turen a Date into a split date&quot;, function() {
    var date = new Date(2012, 10, 17),
        splitDate = dateUtil.convertDateToSplitDate(date);

    expect(splitDate).toEqualDate(date);
});</code></pre></noscript></div>
</p>

<p>I don&rsquo;t know about you, but these tests look a <strong>lot</strong> better to me. While the overall lines of code may have increased, we&rsquo;ve created a reusable solution that can be used over and over again while not repeating ourselves. Our tests now have a single <code>expect</code> that is easy to understand and clearly expresses the intent of the test in an easy to read way.</p>

<h2>Additional Reading</h2>

<p><a href="https://github.com/pivotal/jasmine/wiki/Matchers">Official Documentation on Jasmine Matcher</a></p>

<p><a href="http://lostechies.com/derickbailey/2011/09/03/custom-jasmine-matchers-for-clarity-in-testing-backbone-js-models/">Custom Jasmine Matchers For Clarity In Testing Backbone.js Models</a></p>

<p><a href="http://testdrivenwebsites.com/2010/08/04/custom-jquery-matchers-in-jasmine/">Custom jQuery matchers in Jasmine</a></p>
]]></content>
  </entry>
  
</feed>
