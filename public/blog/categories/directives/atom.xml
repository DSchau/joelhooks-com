<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: directives, | Joel Hooks]]></title>
  <link href="http://joelhooks.com/blog/categories/directives/atom.xml" rel="self"/>
  <link href="http://joelhooks.com/"/>
  <updated>2015-12-31T01:23:40-06:00</updated>
  <id>http://joelhooks.com/</id>
  <author>
    <name><![CDATA[Joel Hooks]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Let's Make Full-Ass AngularJS Directives]]></title>
    <link href="http://joelhooks.com/blog/2014/02/11/lets-make-full-ass-angularjs-directives/"/>
    <updated>2014-02-11T15:45:00-06:00</updated>
    <id>http://joelhooks.com/blog/2014/02/11/lets-make-full-ass-angularjs-directives</id>
    <content type="html"><![CDATA[<p><em>With best intentions we set forth to create the mighty directive. The steepest slope of the dreaded AngularJS learning curve.</em></p>

<h3>The &ldquo;place where the jQuery goes.&rdquo;</h3>

<p>So what is a directive? We&rsquo;ve <a href="http://www.joelhooks.com/blog/2013/07/27/using-angularjs-stop-using-jquery-as-a-crutch/">talked about this before</a>, and decided that they are <strong>not</strong> where the jQuery goes&hellip; usually&hellip; if you <strong>are</strong> going to use jQuery, directives are <strong>definitely</strong> where it should go.</p>

<p>It&rsquo;s easy to say &ldquo;OMG, NO JQUERY&rdquo; &ndash; but what does that actually mean? What does a <strong>really kickass directive</strong> look like?</p>

<h3>The Anatomy of a Good Directive.</h3>

<p>The <a href="https://github.com/angular-ui/bootstrap">ui-bootstrap</a> library is the best singular resource on what a good directive should look like. They are solving multiple common problems in varied ways, with generally solid patterns and practices. It&rsquo;s a robust open-source project, with a constant flurry of activity.</p>

<p>When you start to dig through the library&rsquo;s src, you can see how many different styles and solutions have solved the various problem. Some are extremely complex, while some are relatively simple.</p>

<p>While the solutions <strong>are</strong> varied, there are also some common traits the ui-boostrap directives share across the library.</p>

<h4>Minimal use of the link function</h4>

<p>How many of your project&rsquo;s link functions contain <strong>all the things</strong>?</p>

<p><em>me: raises guilt hand sheepishly</em></p>

<p>Down and dirty, just toss it in the <code>link</code> function.</p>

<p>When you start to browse the ui-bootstrap code, pay attention to the <code>link</code> functions on the directives themselves.</p>

<h5>dropdown</h5>

<p>``` javascript
.directive(&lsquo;dropdown&rsquo;, function() {
  return {</p>

<pre><code>restrict: 'CA',
controller: 'DropdownController',
scope: {
  isOpen: '=?',
  onToggle: '&amp;'
},
link: function(scope, element, attrs, dropdownCtrl) {
  dropdownCtrl.init( element );
}
</code></pre>

<p>  };
})
```</p>

<p>The <strong>Dropdown</strong> directive has a link function, but its sole purpose in life is to associate the directive with a controller.</p>

<p><strong>This is a good thing</strong></p>

<p>Why? Well, to be honest, directives can be a real pain in the ass to unit test. How do you make a directive easy to unit test? Don&rsquo;t give it any functionality.</p>

<p>Controllers, on the other hand, are easy to unit test, so we can avoid the headache of even thinking about unit testing a directive by offloading the logical bits to a controller.</p>

<h4>The directive&rsquo;s controller</h4>

<p>What does it look like? Basically, it looks like a normal controller.</p>

<h5>DropdownController</h5>

<p>``` javascript
.controller(&lsquo;DropdownController&rsquo;, function($scope, $attrs, dropdownConfig, dropdownService, $animate) {
  var self = this, openClass = dropdownConfig.openClass;</p>

<p>  this.init = function( element ) {</p>

<pre><code>self.$element = element;
$scope.isOpen = angular.isDefined($attrs.isOpen) ? $scope.$parent.$eval($attrs.isOpen) : false;
</code></pre>

<p>  };</p>

<p>  this.toggle = function( open ) {</p>

<pre><code>return $scope.isOpen = arguments.length ? !!open : !$scope.isOpen;
</code></pre>

<p>  };</p>

<p>  // Allow other directives to watch status
  this.isOpen = function() {</p>

<pre><code>return $scope.isOpen;
</code></pre>

<p>  };</p>

<p>  $scope.$watch(&lsquo;isOpen&rsquo;, function( value ) {</p>

<pre><code>$animate[value ? 'addClass' : 'removeClass'](self.$element, openClass);

if ( value ) {
  dropdownService.open( $scope );
} else {
  dropdownService.close( $scope );
}

$scope.onToggle({ open: !!value });
</code></pre>

<p>  });</p>

<p>  $scope.$on(&lsquo;$locationChangeSuccess&rsquo;, function() {</p>

<pre><code>$scope.isOpen = false;
</code></pre>

<p>  });
})
```</p>

<p>It&rsquo;s obviously <strong>much</strong> bulkier than the actual directive, but it&rsquo;s also crystal clear what the controller is doing. Normal controller stuff!</p>

<p>One particular item of note is the <code>init</code> function. In the directive above, you probably noticed that the link function did exactly one thing:</p>

<p><code>javascript
dropdownCtrl.init( element );
</code></p>

<p>Since you can&rsquo;t get at the element in the controller, this allows us to still have access to the element, but in a clean, testable, injected way.</p>

<p>If we were going to critique the controller, it might be about its access to <code>$element</code> at all. Is the controller the right place to be doing <em>any</em> DOM manipulation, even if it is ever so slight? Where else would we do that if we aren&rsquo;t going to do it in the <code>link</code> function or the controller?</p>

<p>It needs to go someplace, and pedantic nitpicking is just a hobby.</p>

<h4>Out at the boundaries</h4>

<p>This facet of this clean gem of a directive sparkles bright:</p>

<h5>dropdownService</h5>

<p>``` javascript
.service(&lsquo;dropdownService&rsquo;, function($document) {
  var self = this, openScope = null;</p>

<p>  this.open = function( dropdownScope ) {</p>

<pre><code>if ( !openScope ) {
  $document.bind('click', closeDropdown);
  $document.bind('keydown', escapeKeyBind);
}

if ( openScope &amp;&amp; openScope !== dropdownScope ) {
    openScope.isOpen = false;
}

openScope = dropdownScope;
</code></pre>

<p>  };</p>

<p>  this.close = function( dropdownScope ) {</p>

<pre><code>if ( openScope === dropdownScope ) {
  openScope = null;
  $document.unbind('click', closeDropdown);
  $document.unbind('keydown', escapeKeyBind);
}
</code></pre>

<p>  };</p>

<p>  var closeDropdown = function() {</p>

<pre><code>openScope.$apply(function() {
  openScope.isOpen = false;
});
</code></pre>

<p>  };</p>

<p>  var escapeKeyBind = function( evt ) {</p>

<pre><code>if ( evt.which === 27 ) {
  closeDropdown();
}
</code></pre>

<p>  };
})
```</p>

<p>The AngularJS &lsquo;service&rsquo; is where the boundaries of our applications live.</p>

<ul>
<li>connections to the outside world</li>
<li>domain/data models</li>
<li>core logic</li>
<li>&hellip;</li>
<li>the DOM?</li>
</ul>


<p>This actor is wonderful. It connects <strong>all the dropdowns</strong> and manages their shared state. In this case, we can only have one open drop down on the page. <code>dropdownService</code> keeps track of who that is, and if another drop down is opened, it snaps the current one shut before allowing the next to open.</p>

<p>Additionally, the service listens for events on the <code>document</code> to close the open drop down if the user clicks the page or hits the <code>esc</code> key.</p>

<p>One central place to encapsulate what would otherwise be confusing spaghetti logic on line 342 of a typical directive&rsquo;s <code>link</code> function.</p>

<h3>Pause and study</h3>

<p>It really pays to take pause and review a little code when you sit down to write a complex directive. For one, ui-bootstrap covers a lot of ground. The entire point of Bootstrap (proper) is to provide a robust set of <em>typical</em> components. Meaning, odds are the component you are building (at least the soul of it) is likely covered by the Boostrap component set.</p>

<p>ui-bootstrap conveniently provides this world class reference implementation of the most common web application components&hellip; the Angular Wayâ„¢.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Directives That Override Standard HTML Tags]]></title>
    <link href="http://joelhooks.com/blog/2013/07/15/a-look-at-angularjs-internal-directives-that-override-standard-html-tags/"/>
    <updated>2013-07-15T13:22:00-05:00</updated>
    <id>http://joelhooks.com/blog/2013/07/15/a-look-at-angularjs-internal-directives-that-override-standard-html-tags</id>
    <content type="html"><![CDATA[<p>Directives are the heart and soul of AngularJS. They are incredibly powerful.
AngularJS sets out to extend the grammar of the browser to supply semantics that
facilitate the creation of web applications, going beyond the standard
hyper-linked web page. The primary weapon to accomplish this is the directive.</p>

<p>Creating your own directives is an awesome way to create composed, reusable
behaviors in your applications. This article isn&rsquo;t about making your own
directives, instead I wanted to take a closer look at the internal directives of
AngularJS. Specifically, we will be looking at how and why AngularJS extends the
functionality of native HTML tags like <code>&lt;input&gt;</code> and <code>&lt;a&gt;</code> to make the magic
happen.</p>

<h2>A is for Anchor</h2>

<p>``` javascript
var htmlAnchorDirective = valueFn({
  restrict: &lsquo;E&rsquo;,
  compile: function(element, attr) {</p>

<pre><code>if (msie &lt;= 8) {

  // turn &lt;a href ng-click=".."&gt;link&lt;/a&gt; into a stylable link in IE
  // but only if it doesn't have name attribute, in which case it's an anchor
  if (!attr.href &amp;&amp; !attr.name) {
    attr.$set('href', '');
  }

  // add a comment node to anchors to workaround IE bug that causes element content to be reset
  // to new attribute content if attribute is updated with value containing @ and element also
  // contains value with @
  // see issue #1949
  element.append(document.createComment('IE fix'));
}

return function(scope, element) {
  element.on('click', function(event){
    // if we have no href url, then don't navigate anywhere.
    if (!element.attr('href')) {
      event.preventDefault();
    }
  });
}
</code></pre>

<p>  }
});
```</p>

<p>The <a href="https://github.com/angular/angular.js/blob/master/src/ng/directive/a.js"><code>htmlAnchorDirective</code></a> has a simple job. It is there to prevent navigation and page reloading. Typically this is in conjunction with <code>ng-click</code>, which is used to actually capture the click and navigate the user within the application. Every <code>&lt;a&gt;</code> in your application is effectively extended by AngularJS. The functionality is primarily the <code>event.preventDefault()</code> that is applied if the anchor tag doesn&rsquo;t have an <code>href</code> attribute.</p>

<p>One thing to note, and this is typical throughout the AngularJS internals, is that this directive requires special attention for IE 7. When I&rsquo;m digging around in the internals, I&rsquo;m always appreciative of this effort made by the AngularJS contributors. These aren&rsquo;t fun problems to solve, and it is nice that somebody has made the effort to solve them for us :></p>

<h2>Digging into &lt;form></h2>

<p><a href="https://github.com/angular/angular.js/blob/master/src/ng/directive/form.js">AngularJS overrides <code>&lt;form&gt;</code></a> to provide some important functionality. The core of this extension of <code>&lt;form&gt;</code> is to prevent any page refresh that would occur with an unmodified <code>&lt;form&gt;</code> tag. Lets have a look:</p>

<p>``` javascript
var formDirectiveFactory = function(isNgForm) {
  return [&lsquo;$timeout&rsquo;, function($timeout) {</p>

<pre><code>var formDirective = {
  name: 'form',
  restrict: 'E',
  controller: FormController,
  compile: function() {
    return {
      pre: function(scope, formElement, attr, controller) {
        if (!attr.action) {
          // we can't use jq events because if a form is destroyed during submission the default
          // action is not prevented. see #1238
          //
          // IE 9 is not affected because it doesn't fire a submit event and try to do a full
          // page reload if the form was destroyed by submission of the form via a click handler
          // on a button in the form. Looks like an IE9 specific bug.
          var preventDefaultListener = function(event) {
            event.preventDefault
              ? event.preventDefault()
              : event.returnValue = false; // IE
          };

          addEventListenerFn(formElement[0], 'submit', preventDefaultListener);

          // unregister the preventDefault listener so that we don't not leak memory but in a
          // way that will achieve the prevention of the default action.
          formElement.on('$destroy', function() {
            $timeout(function() {
              removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);
            }, 0, false);
          });
        }

        var parentFormCtrl = formElement.parent().controller('form'),
            alias = attr.name || attr.ngForm;

        if (alias) {
          scope[alias] = controller;
        }
        if (parentFormCtrl) {
          formElement.on('$destroy', function() {
            parentFormCtrl.$removeControl(controller);
            if (alias) {
              scope[alias] = undefined;
            }
            extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards
          });
        }
      }
    };
  }
};

return isNgForm ? extend(copy(formDirective), {restrict: 'EAC'}) : formDirective;
</code></pre>

<p>  }];
};
```</p>

<p>The above function is a factory that creates a form directive. The directive itself does several things. Aside from some memory management it also serves to prevent the default behavior of the form action. Typically with an AngularJS application, you will want to capture the user&rsquo;s input it a form, and feed that data into a controller to send it to the server. This is different from the standard <code>action</code> attribute of a form that will perform a POST operation and typically redirect the user to a new page. This behavior is probably not what you want in your single-page JavaScript application, so AngularJS is working to help prevent that. You probably still want to be able to submit your form, and the <code>ngSubmit</code> directive placed as an attribute on the <code>&lt;form&gt;</code> tag will execute an expression when your designated submit input is clicked.</p>

<p>If you&rsquo;re paying close attention, you&rsquo;ll notice that the form directive above has a <code>FormController</code> assigned to it. The <code>FormController</code> is the brains of all the forms within an AngularJS application, and every <code>&lt;form&gt;</code> gets one. The <code>FormController</code> tracks all of the controls within a form and manages the validity of the form.</p>

<h2>The Input Directive</h2>

<p>``` javascript
var inputDirective = [&lsquo;$browser&rsquo;, &lsquo;$sniffer&rsquo;, function($browser, $sniffer) {
  return {</p>

<pre><code>restrict: 'E',
require: '?ngModel',
link: function(scope, element, attr, ctrl) {
  if (ctrl) {
    (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer,
                                                        $browser);
  }
}
</code></pre>

<p>  };
}];
```</p>

<p>Wow! It&rsquo;s so simple ;)</p>

<p>It is. This is because <a href="https://github.com/angular/angular.js/blob/master/src/ng/directive/input.js">the actual <code>&lt;input&gt;</code> tag</a> is only the entry point. The real work is done based on the <strong>type</strong> of input that is being used. AngularJS is looking for the following input types:</p>

<ul>
<li>text</li>
<li>number</li>
<li>url</li>
<li>email</li>
<li>radio</li>
<li>checkbox</li>
</ul>


<p>With the URL, email, and number types, AngularJS provides some basic validation:</p>

<p><code>javascript
var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&amp;%@!\-\/]))?$/;
var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$/;
var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
</code></p>

<p>Here&rsquo;s the code for the URL type:</p>

<p>``` javascript
function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);</p>

<p>  var urlValidator = function(value) {</p>

<pre><code>if (isEmpty(value) || URL_REGEXP.test(value)) {
  ctrl.$setValidity('url', true);
  return value;
} else {
  ctrl.$setValidity('url', false);
  return undefined;
}
</code></pre>

<p>  };</p>

<p>  ctrl.$formatters.push(urlValidator);
  ctrl.$parsers.push(urlValidator);
}
```</p>

<p>Simple stuff. It is using the REGEX above and setting the validity on the <code>FormController</code>, which you can then use to display feedback to the user. Email and number validation works in a similar fashion.</p>

<p>With text-type inputs AnglularJS also provides <strong>data-binding</strong> via <code>ngModel</code>, which is an extremely convenient solution to capturing user input and displaying it in the form. We should look at <code>ngModel</code> a bit closer in a future post.</p>

<h2>Just the beginning.</h2>

<p>It wasn&rsquo;t immediately obvious to me when I started using AngularJS that the framework was overriding these default HTML tags to add the secret sauce on top. Once the realization dawned on me, it opened my eyes to the power and potential that directives hold. You aren&rsquo;t restricted to the extensions that AngularJS provides with these built-in directives. You can further extend the capabilities of HTML by creating your own directives that override and extend the native HTML elements.</p>

<p>Digging into the guts of the <a href="https://github.com/angular/angular.js/tree/master/src">AngularJS source code</a> is a great way to learn the hows and whys of the framework, and can reveal techniques that can be applied to your own applications. The AngularJS source is well documented, cleanly written, and well tested. If you&rsquo;re working with AngularJS, I highly recommend diving into these internals and discovering this for yourself. It won&rsquo;t be time wasted.</p>

<p>You might also enjoy: <a href="http://joelhooks.com/blog/2013/05/22/lessons-learned-kicking-off-an-angularjs-project/"><strong>Lessons Learned: A Year with a Large AngularJS Project</strong></a></p>

<p>or maybe: <a href="http://joelhooks.com/blog/2013/08/03/learn-angularjs-in-a-weekend/"><strong>Learn AngularJS this Weekend</strong></a></p>
]]></content>
  </entry>
  
</feed>
